# 원시 값

- 원시 값 = 변경 불가능한 값
- 읽기전용 값으로서 변경 불가능
- 변수 ⇒ 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 or 메모리 공간을 식별하기 위해 붙인 값
- 값 ⇒ 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과
- 변경 불가능하다는 것은 **변수가 아닌 값에** 대한 진술
- 즉, "원시 값은 변경 불가능하다."
  - `원시 값 자체를 변경할 수 없다. → O`
  - `변수 값을 변경할 수 없다. → X`
- 변수 vs 상수
  - 상수는 변수의 상대개념으로서 재할당이 금지된 변수
  - 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고도 할 수 있다
  - 단, 변수는 언제든지 재할당을 통해 변수 값을 변경(교체) 할 수 있지만 상수는 불가능
  - 상수는 재할당이 금지된 변수!

### 불변성

- 변수값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후 , 변수가 참조하던 메모리 공간의 주소를 변경하는 특성
- 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없음

<br>

## 문자열과 불변성

- 자바스크립트는 원시타입인 문자열 타입을 제공

```jsx
var str = "Hello";
str = "world";
```

⇒ 이전에 생성된 문자열 ‘Hello’를 수정하는 것이 아닌 새로운 문자열 ‘world’를 메모리에 생성하고 식별자인 str은 그 ‘world’를 가리킴

⇒ ‘Hello’ 와 ‘world’ 모두 메모리에 존재하고 식별자가 가리키는 것이 변경되었을 뿐임

- 문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근 가능!

```jsx
var str = "string";
str[0] = "S";

console.log(str); // "string"
```

⇒ 문자열은 변경 불가능한 값이기 때문에 일부 문자 변경해도 반영되지 않음

⇒ 변수에 새로운 문자열을 재할당하는 것은 가능 ⇒ 새로운 문자열을 새롭게 할당하는 것이므로

<br>

## 값에 의한 전달

```jsx
var score = 80;
var copy = score;

console.log(score); // 80 (원본 값)
console.log(copy); // 80  (복사한 값)
console.log(score === copy); //true

score = 100;

console.log(score); // 100 (원본 값)
console.log(copy); // 80  (복사한 값)
console.log(score === copy); //false
```

⇒ 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 **원시 값이 복사되어** 전달 = **값에 의한 전달**

- score 변수와 copy변수는 숫자 80을 갖는다는 점에서 동일하지만 다른 메모리 공간에 저장된 **별개의 값!**
- 다른 메모리 공간에 저장된 별개의 값이므로 score 변수를 변경해도 copy 변수의 값에는 아무런 영향을 미치지 않음

### 값에 의한 전달은 자바스크립트를 위한 용어가 아님

- 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문
- 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문
- 식별자로 값을 구별해서 식별하는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근하는 것!
- **값에 의한 전달도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달!**
  - 결국 두변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이되어 어느 한 쪽에서 재할당을 통해 값을 변경해도 서로 간섭 불가능

<br>

# 객체

- 객체 = 변경 가능한 값
- 객체는 프로퍼티의 개수가 정해져 있지 않음
- 동적으로 추가되고 삭제 가능, 프로퍼티 값에 제약 없음
- 객체는 원시갑소가 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없음

### 자바스크립트 객체의 관리 방식

- 자바스크립트 객체는 키를 인덱스로 사용한느 해시테이블이라고 생각할 수 있음
- 클래스 없이 객체를 생성할 수 있으며 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있음
- 편리하지만 성능 면에서는객체지향프로그래밍 언어의 객체보다 비효율적
- 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적탐색 대신 히든 클랙스 방식 사용해 성능 보장

### 변경 가능한 값

```jsx
var person = {
  name: "Lee",
};

console.log(person); // {name:"Lee"} => person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근

person.name = "Kim"; // 프로퍼티 값 갱신

person.address = "Seoul"; // 프로퍼티 동적 생성

console.log(person); // {name:"Kim", address:"Seoul"}
```

- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조 값**에 접근 가능
  - 참조값은 생성된 객체가 저장된 메모리 공간의 주소 그자체
- 원시 값은 변경 불간읗나 값이므로 원시값을 갖는 변수를 변경하려면 재할당 말고는 방법이 없음
- 하지만 객체는 변경 간으한 값! ⇒ 재할당 없이 객체를 직접 변경할 수 있음
- 즉 재할당없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있음

- 객체를 생성하고 관리하는 방식은 매우 복잡하며 비용이 많이 드는 일
  - 객체 크기가 매우 클 수도 있고 크기가 일정하지도 않으며 프로퍼티 값이 객체일 수도 있어서 복사해서 생성하는 비용이 많이 듦
  - 따라서 효율적인 메모리 사용을 위해 객체는 변경가능한 값으로 설계
- 객체는 이러한 구조적 단점에 따른 부작용 존재
  - 여러개의 식별자가 하나의 객체를 공유할 수 있다는 점
  ### 얕은 복사 vs 깊은 복사
  - 얕은 복사 = 한 단계까지만 복사
  - 깊은 복사 = 객체에 중첩되어 있는 객체까지 모두 복사
  - 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체
    - 얕은 복사는 객체에 중접되어 있는 경우 참조값을 복사
    - 깊은 복사는 중첩되어있는 개체까지 모두 복새에 원시값처럼 완전한 복사본을 만드는 것

### 참조에 의한 전달

- 여러개의 식별자가 하나의 객체를 공유할 수 있어 부작용이 발생한다고 했음

```jsx
var person = {
  name: "Lee",
};

var copy = person; // 참조 값 복사(얕은 복사)

console.log(copy === person); //true => 동일한 객체를 참조

copy.name = "Kim";

person.address = "Seoul";

console.log(person); //{name: 'Kim', address:"Seoul"}
console.log(copy); //{name: 'Kim', address:"Seoul"}
// 동일한 객체를 가르키므로 어느 한쪽을 변경하면 서로 영향을 주고 받음
```

⇒ 원본의 참조 값이 복사되어 전달 = 참조에 의한 전달

- 저장된 메모리 주소는 다르지만 동일한 참조 값을 가짐
- 원본과 사본 모두 동일한 객체를 가리킴 ⇒ 두개의 식별자가 하나의 객체를 공유
- 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받음!

### 값에 의한 전달 vs 참조에 의한 달

- 값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어있는 값을 복사해서 전달한다는 면에서는 동일!
- 식별자가 기억하는 메모리 공간에 있는 값이 원시 값인지 참조 값인지의 차이만 있을뿐
- **따라서 자바스크립트에는 값에 의한 전달만 존재!**
  - 자바스크립트에는 포인터가 존재하지 않기때문에 참조에 의한 전달이 다른 프로그래밍 언어와 일치하지 않음

```jsx
var person1 = {
  name: "Lee",
};

var person2 = {
  name: "Lee",
};

console.log(person1 === person2); //false
console.log(person1.name === person2.name); // true
```

⇒ person1 변수와 person2 변수의 참조값은 전혀 다른 값

⇒ 하지만 [person1.name](http://person1.name) 같은 값은 값으로 평가될 수 있는 표현식이므로 두 표현식 모두 원시 값 ‘Lee’로 평가됨
