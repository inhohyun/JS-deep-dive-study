# 원시 값

## 원시 값 === 변경 불가능한 값
- 한번 생성된 원시 값은 읽기 전용값... **변경 불가능!** => 데이터의 신뢰성 보장
- 변경 불가능하다 == 값에 대한 진술... 변수는 언제든지 재할당 통해 그 값 변경 가능!

### 변수와 값 
- 변수 : 하나의 값을 저장하기 위해 확보한 **메모리 공간** 혹은 그 **메모리 공간 식별을 위한 이름**
- 값 : 변수에 저장된 데이터... 표현식이 평가되어 생성된 결과

### 상수
- 재할당이 금지된 변수... 변수와 상대 개념
- 값 저장 위한 메모리 공간 필요... 변수라고 지칭 가능
- 변수와 달리 단 한번만 할당 허용... 변수 값 교체 불가능!
- ``상수 != 변경 불가능한 값``

### 불변성(원시 값 할당한 변수) 가지는 값 변경 3단계
1. 새로운 메모리 공간 확보해 재할당한 원시 값 저장
2. 이후 변수는 새롭게 재할당한 원시 값 가리킴
3. 이때 변수가 참조하던 메모리 공간의 주소 바뀜!
   - 변수에 할당된 원시 값이 변경 불가능한 값이기 때문
   - 재할당 외에는 변수 값 변경할 수 있는 방법 x

## 문자열과 불변성
### 자바스크립트는 문자열 타입을 원시 타입으로 제공... 타입 변경 불가능!
    ```javascript
    var str = 'Hello!';
    str = 'world';
    ```
- 'Hello', 'world' 모두 메모리에 존재
- 식별자 str은 문자열 'Hello' 가리키다가 문자열 'world' 가리키도록 변경
### 문자열 === 유사 배열 객체이면서 이터러블.. 배열과 유사하게 각 문자에 접근 가능!
- 유사 배열 객체 : idx로 프로퍼티 값에 접근 가능, length 프로퍼티 갖는 객체
    ```javascript
    var str = 'string';
    str[0] = S;
    console.log(str);
    ```
    - 이미 생성된 문자열의 일부 문자 변경해도 반영 x... 문자열 == 변경 불가능한 값이기 때문!
    - 문자열의 값 변경 위해서는 기존 문자열 변경이 아닌, **새로운 문자열을 새롭게 할당!**

## 값에 의한 전달
### 변수에 변수 할당
```javascript
var score = 80;

var copy = score;
// 할당받는 변수(copy)에 할당되는 변수(score)의 원시 값이 복사되어 전달

console.log(score, copy); // 80 80
console.log(score === copy);  // true

score = 100;

console.log(score, copy); // 100 80
console.log(score === copy);  // false
// score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값!!
// score 값 변경해도 copy에는 영향 x
```

### "값에 의한 전달"은 JavaScript 전용 용어 아님!!
- 변수에는 값이 아니라 메모리 주소가 전달...
    - 식별자 : 어떤 값을 구별하여 식별할 수 있는 고유한 이름
    - 변수와 같은 식별자는 값이 아닌 메모리 주소를 기억하기 때문!
    - 전달된 메모리 주소를 통해 메모리 공간에 접근해 값 참조!
- 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값...
    - 어느 한쪽에서 재할당 통해 값 변경해도 서로 간섭 x




# 객체

## 객체란?
- 프로퍼티의 개수 정해지지 않음
- 동적으로 추가 및 삭제 가능
- 프로퍼티의 값에 제약 x
- **확보해야 할 메모리 공간의 크기 사전에 정하지 못함!!!**

### JavaScript에서 객체의 관리 방식
- 프로퍼티 키를 idx로 사용하는 해시 테이블 느낌
- 클래스 없이 객체 생성 가능
- 객체 생성된 이후라도 동적으로 프로퍼티, 메서드 추가 가능
- 사용하기에는 편하지만, 이론적으로 클래스 기반 객체 지향 프로그래밍 언어 객체보다 생성 및 프로퍼티 접근 비용 많이 듦(비효율적임)

### 변경 가능한 값!
- 객체 할당한 변수가 기억하는 메모리 주소 통해 메모리 공간에 접근하면 참조 값에 접근..
    - 참조 값: 메모리 공간의 주소 그 자체
- 재할당 없이 객체 직접 변경 가능(crud 가능!!)
- 이는 **메모리의 효율적 사용**, **비용 절감을 통한 성능 향상** 위한 설계!!!

```javascript
var person = {
    name: 'Lee'
};

// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근
console.log(person);  // {name: 'Lee'}

// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 생성
person.address = 'Seoul';

console.log(person);  // {name: 'Kim', address: 'Seoul'}
```

## 객체 구조의 부작용 존재...
- 여러 개의 식별자가 하나의 객체 공유 가능
- 한 쪽에서 객체 바꾸면 같은 객체 공유하는 다른 쪽에도 영향 미침

### 얕은 복사, 깊은 복사
- 얕은 복사 : 참조값을 복사
- 깊은 복사 : 객체에 중첩되어 있는 객체까지 모두 복사하여 원시 값처럼 완전한 복사본 만듦

### 참조에 의한 전달
```javascript
var person = {
    name: 'Lee'
};

// 객체 가리키는 변수(원본 - person)을 다른 변수(사본 - copy)에 할당..
// 원본의 참조 값이 복사되어 전달
var copy = person;

// copy와 person 모두 동일한 객체를 참조
// 두 개의 식별자가 하나의 객체를 공유...
console.log(copy === person); // true

copy.name = 'Kim';

person.address = 'Seoul';

// 한쪽에서 객체 바꾸면 다른 쪽에도 영향을 줌
console.log(person);  // {name: 'Kim', address: 'Seoul'}
console.log(copy);  // {name: 'Kim', address: 'Seoul'}
```

## JavaScript에는 "값에 의한 전달"만 있다!
- 값에 의한 전달, 참조에 의한 전달은 **식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해 전달**한다는 면에서 동일!
- 차이점은 **변수에 저장된 값이 원시 값이냐 vs. 참조 값이냐**...
- 따라서 JavaScript에는 "값에 의한 전달"만 존재한다고 이야기할 수 있음!