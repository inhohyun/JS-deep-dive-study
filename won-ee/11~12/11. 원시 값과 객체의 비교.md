# 원시 값과 객체의 비교
## 원시값
- 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다. 다시말해, 한번 생성된 원시 값은 읽지 전용 값으로서 변경할 수 없다.
- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체, 또는 그 메모리 공간을 식별하기 위해 붙인이름, 값은 변수에 저장된 데이터로 표현식이 평가되어 생성된 결과이다
->  변경이 불가능하다는 것은 변수가 아니라 값이다.

**원시값을 할당한 변수에 새로운 원시 값을 재할당 하면 메모리  공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시값을 가르키고, 변수가 참조하던 메모리 공간의 주소가 바뀐다.**
### 값의 이러한 특성을 불변성이라고 한다.

## 객체
- 객체 타입의 값, 즉 객체는 변경가능한 값이다.
- 원시값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시값에 접근할 수 있다.
즉, 원시값을 할당한 변수는 원시값 자체를 값으로 갖는다.
- 하지만, 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조값**에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그자체이다.

**원시값은 변경 불가능한 값이므로 원시값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다. 하지만 객체는 변경가능한 값이다. 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 즉, 재할당 없이 프로퍼티를 동적으로 추가할수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.**

## 얕은 복사와 깊은 복사
- 객체는 이러한 구조적 단점에 따른 부족용이 있다. 그것은 원시 값과는 다르게 여러개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.

### 얕은복사
- 얕은 복사는 객체의 최상위 프로퍼티만 복사하며, 내부의 객체는 잠고를 공유한다. 즉, 복사된 객체와 원본 객체는 같은 내부 객체를 잠조하게 된다.
```js
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

console.log(user.sizes === clone.sizes); // true, 같은 객체입니다

// user와 clone은 sizes를 공유합니다
user.sizes.width++;
console.log(clone.sizes.width); // 51, 다른 객체에서 변경 사항을 확인할 수 있습니다
```
여기서 `Object.assign`을 사용한 얕은 복사는 `sizes`의 객체의 참조만 복사하므로 `user`와 `clone`은 같은 `sizes`객체를 공유한다.

### 깊은 복사
- 깊은복사는 객체의 모든 프로퍼티와 중첩된 객체를 완전히 복제하여 원본 객체와 독립적인 복사본을 생성한다. 이를 위햇 각 객체의 구조를 재귀적으로 복사해야 한다.
```js
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

// lodash 라이브러리의 _.cloneDeep을 사용한 깊은 복사
let clone = _.cloneDeep(user);

console.log(user.sizes === clone.sizes); // false, 서로 다른 객체입니다
 
user.sizes.width++;
console.log(clone.sizes.width); // 50, clone에는 영향을 주지 않음
 let deepClone = JSON.parse(JSON.stringify(obj));
 ```
 여기서서 `_.cloneDeep`을 사용하여 깊은 복사를 수행하면, `user`와 `clone`은 완전히 독립적인 `sizes`객체를 가진다. 따라서 한 객체의 변경이 다른 객체에 영향을 미치지 않는다.

 - **얕은복사는 객체의 최상위 프로퍼티만 복사하며, 중첩된 객체는 참조를 공유한다. `Object.assign`이나 스프레드연산자(`{ ...obj }`)를 이용해 복사할수 있다.**

- **깊은 복사는 객체와 그 내부의 모든 중첩 객체를 복사하여 완전히 독립적인 복사본을 생성한다. `_.cloneDeep`과 같은 라이브러리를 사용하거나, 직접 재귀적인 함수를 작성하여 구현할수 있다.**